package fi.tuni.tiko.digging;

import com.badlogic.gdx.math.MathUtils;

import java.util.ArrayList;
import java.util.Iterator;

import static fi.tuni.tiko.digging.MainGame.TILES_IN_ROWS_INCLUDING_EDGES;
import static fi.tuni.tiko.digging.MainGame.TILES_IN_ROWS_WITHOUT_EDGES;
import static fi.tuni.tiko.digging.Root.CLOSES;
import static fi.tuni.tiko.digging.Root.CONTINUES;

public class StageRandomizer {

    //GameTile[][] tiles;

    //näyttäisi tomivan ilman tätä tai inttiä ensin joka palautetaan

    ArrayList<AreaTemplate> areaTemplates = new ArrayList<>();
    /*
    DirtPool dirtPool;
    StonePool stonePool;
    BlankPool blankPool;
    DescendingPool descendingPool;
    */
    TilePools tilePools;

    private static final boolean LEFTROOT = false;
    private static final boolean RIGHTROOT = true;

    private static final int STARTING_TILE = 1;

    private static final int HORIZONTAL_HAZARD_NOT_ALLOWED = 2;

    private static final int KEYTILE = 3;

    private static final int HAZARDFREETILE = 4;

    private static final int PASSAGERIGHT=1;
    private static final int PASSAGELEFT=-1;

    int[][] passages;



    public StageRandomizer(TilePools tilePools) {
        this.tilePools = tilePools;
    }



    public GameTile[][] areas (MapTemplate mapTemplate) {


        areaTemplates.clear();
        //ArrayList<AreaTemplate> areaTemplates = mapTemplate.getArrayList();
        areaTemplates = mapTemplate.getArrayList();

        //x0 is "farm" row
        //x1-4 are guaranteed all dirt
        //x last one will be all stone so arraySize 6 all in total cause it starts from 1 in counter

        int arraySize = 6;

        /*goes through all previously randomized areas (rows and cols are already generated by now)
        and checks how many rows there are in total, so we will know how many rows there will be
        in the array we will generate afterwards. arraySize will be added to the number since those
        will always be there
         */
        for (int i=0; i < areaTemplates.size(); i++) {
            AreaTemplate at = areaTemplates.get(i);
            arraySize += at.getRows();
        }
        //9 will always be the size of the map at current version hmm. that could also be some static
        //final
        GameTile[][] tiles = new GameTile[arraySize][TILES_IN_ROWS_INCLUDING_EDGES];

        //lisää edgejä lukuunottamatta koko homman stoneksi, edgetkin voisi mutta ehkä parempi pitää erillään jos niitä vaihdetaankin
        for (int y = 1; y< tiles.length-1; y++) {
            for (int x = 1; x < tiles[0].length-1; x++) {
                StoneTile stone = tilePools.getStonePool().obtain();
                tiles[y][x] = stone;
                stone.setInPlace(y,x);
            }

        }

        //there must be a guranteed entrance in the same spot as last areas exit posX.
        //also startingPosX is added to the templates so we know how many stone tiles to generate

        addStartingPosXandExitToAreaTemplates();

        tiles =addStoneEdgesUsingTemplates(tiles);

        tiles =addRandomTiles(tiles, mapTemplate);


        return tiles;


    }

    public GameTile[][] addRandomTiles(GameTile[][] tiles, MapTemplate mapTemplate) {

        int chanceOfBlankTile=mapTemplate.getTerrainTemplate().getChanceOfDirtTileBeingBlank();
        int chanceOfStoneTile=mapTemplate.getTerrainTemplate().getChanceOfDirtTileBeingStone();
        int chanceOfDescendingTile=mapTemplate.getTerrainTemplate().getChanceOfDirtTileBeingDescending();

        for(int y=5; y<tiles.length; y++) {
            for (int x=1; x<tiles[0].length; x++) {
                //GameTile currentTile = tiles[y][x];
                if (tiles[y][x] instanceof DirtTile ) {
                    //System.out.println("found dirtTile");

                    int randomResult=MathUtils.random(1, 100);
                    //System.out.println(randomResult);
                    if (randomResult<=chanceOfBlankTile) {
                        //System.out.println("blank chance happened");

                        tilePools.getDirtPool().free((DirtTile)tiles[y][x]);

                        BlankTile blank = tilePools.getBlankPool().obtain();
                        tiles[y][x] = blank;
                        blank.setInPlace(y,x);


                    } else if ( (randomResult>chanceOfBlankTile) && (randomResult <= (chanceOfBlankTile+chanceOfStoneTile)) ) {
                        //System.out.println("stone chance happened");

                        tilePools.getDirtPool().free((DirtTile)tiles[y][x]);

                        StoneTile stone = tilePools.getStonePool().obtain();
                        tiles[y][x] = stone;
                        stone.setInPlace(y,x);
                        
                    } else if ( (randomResult> (chanceOfBlankTile+chanceOfStoneTile) ) && (randomResult <= (chanceOfBlankTile+chanceOfStoneTile+chanceOfDescendingTile)) ) {
                        //System.out.println("descending chance happened");

                        tilePools.getDirtPool().free((DirtTile)tiles[y][x]);

                        DescendingDirtTile descending = tilePools.getDescendingPool().obtain();
                        tiles[y][x] = descending;
                        descending.setInPlace(y,x);



                    }


                }
            }
        }

        return tiles;
    }

    public GameTile[][] addStoneEdgesUsingTemplates(GameTile[][] tiles) {

        //start from 5 since 1-4 are all dirt and 0 is "farm" tiles
        AreaTemplate aTemplate= areaTemplates.get(0);
        int areaTemplateCounter = 0;
        int areaTemplateRowCounter = 0;

        for (int y=5; y<tiles.length - 1; y++) {
            //for (int x = 1; x < tiles[0].length-1; x++) {


            for (int x = aTemplate.getStartingPosX(); x < aTemplate.getStartingPosX()+aTemplate.getCols(); x++) {

                tilePools.getStonePool().free((StoneTile)tiles[y][x]);

                DirtTile dirt = tilePools.getDirtPool().obtain();
                tiles[y][x]= dirt;
                dirt.setInPlace(y,x);
            }
            areaTemplateRowCounter++;
            //System.out.println("y: "+y);
            //System.out.println("AtemplateRowCounter: "+areaTemplateRowCounter);

            if(areaTemplateRowCounter == aTemplate.getRows()) {
                areaTemplateRowCounter=0;
                //System.out.println("areaTemplateRowCounterFOund");
                areaTemplateCounter++;
                if (areaTemplateCounter < areaTemplates.size() ) {
                    aTemplate = areaTemplates.get(areaTemplateCounter);

                }

            }

        }



        return tiles;

    }

    public void addStartingPosXandExitToAreaTemplates() {

        //this needs to be randomed so there will be some value in the first area.
        int lastAreasExitPosX = MathUtils.random(1,TILES_IN_ROWS_WITHOUT_EDGES+1);

        for (int i=0; i<areaTemplates.size(); i++) {
            AreaTemplate aTemplate = areaTemplates.get(i);
            aTemplate = giveStartingRowAndExitTile(aTemplate , lastAreasExitPosX);

            lastAreasExitPosX=aTemplate.getExitPosX();
            //lastAreasExitPosX=2;
        }


    }




    /*giveStartingRowAndExitTile(...) is just a precaution to make it absolutely sure that there is at least one tile
    where player can dig into another area without hitting a stone block.
    Note: There will be another method (NAME HERE) which will make sure there is a possible route
    of non-permanent tiles that player can take between the areas
     */

    private AreaTemplate giveStartingRowAndExitTile (AreaTemplate at, int lastAreasExit) {
        //int[] toBeReturned = new int[2];
        int howManyTilesInArow = at.getCols();
        int posXstart = -9999;

        /*it will keep randomizing the startingRow as many times as it's needed to make it sure that
        there is possibility to dig from one area to another. (lastAreasExit PosX...)
         */

        while ( (lastAreasExit < posXstart) || (lastAreasExit > posXstart+howManyTilesInArow) ) {
            posXstart = MathUtils.random(1, (1+TILES_IN_ROWS_WITHOUT_EDGES-howManyTilesInArow) );
            //System.out.println("posXstart: "+posXstart+", lastAreasExit: "+lastAreasExit);
        }

        //will hold the info of one dirt-tiled x-position, that will be the guaranteed entrance x-position in the next  area
        at.setStartingPosX(posXstart);

        //might need work, but if there will never be impossibility to go to next area just let it be
        at.setExitPosX(MathUtils.random(posXstart,posXstart+howManyTilesInArow-1) );

        //tähän vaan set x johonkin niistä randomeista ei se sen kummempi oo



        return at;
    }

    public GameTile[][] addRoots (GameTile[][] tiles) {

        //these can be measured later according to stage/area that is played (early game=more roots, middle game=least roots)
        int leftRootChance=18;
        int rightRootChance=23;

        //entrance row won't have a root
        for (int y=1; y<tiles.length-2; y++) {
            int leftRandomResult=MathUtils.random(1, 100);
            int rightRandomResult=MathUtils.random(1,100);

            if (leftRandomResult <= leftRootChance) {
                tiles = addRoot(tiles, LEFTROOT, y);
            }
            //making this else if instead of just if, so the bugged roots wont appear. dont know how they started to become even though
            //I didnt touch anything here and I had fixed it. I made some mistake in RootResourceTile maybe
            else if (rightRandomResult <= rightRootChance) {
                tiles = addRoot(tiles, RIGHTROOT, y);
            }
        }

        return tiles;
    }

    public GameTile[][] addRoot (GameTile[][] tiles, boolean side, int y) {

        boolean reachedClosing=false;
        boolean continues = true;

        //default values are for LEFTROOT
        int modifier = 1;

        int startingX=0;


        if (side == RIGHTROOT) {
            modifier = -1;

            startingX = TILES_IN_ROWS_INCLUDING_EDGES-1;

        }


        for (int x=startingX; continues; x = x+modifier) {
            Root root = tilePools.getRootPool().obtain();
            root.setStatus(CONTINUES);
            //to prevent index out of bound hmm

            //AINIIN TÄMÄ EHKÄ KORJAANTUU SILLÄ KUN LAITTAA ETTEI VOI OLLA PELKKIÄ STONE
            //JUTTUJA niin voi tämän koko loopin ottaa pois
            if (x >= 0 && x <= TILES_IN_ROWS_INCLUDING_EDGES-1) {


                if (tiles[y][x] instanceof PermanentTile || tiles[y][x] instanceof StoneTile) {
                    //not sure if XOR should be used here, nothing is needed now in this loop
                } else {
                    root.setStatus(CLOSES);
                    reachedClosing=true;
                }

                if (side == LEFTROOT) {
                    //System.out.println("trying to flip");
                    root.flipDirection();
                    root.updateTexture();
                }

                root.updateTexture();
                //tiles[y][x].setRoot(root);

                if (reachedClosing) {

                    boolean abortionNeeded = false;


                    //we will do an abortion to this root, if there is already rootClosing from the other side

                    if (tiles[y][x].getRoot() == null) {
                        tiles[y][x].setRoot(root);

                    } else {
                        abortionNeeded = true;
                    }


                    if (abortionNeeded) {
                        tilePools.getRootPool().free(root);
                        boolean abortionContinues = true;
                        int endingX = 0;
                        int abortionModifier = -1;
                        if (side == RIGHTROOT) {
                            endingX = TILES_IN_ROWS_INCLUDING_EDGES - 1;
                            abortionModifier = +1;
                        }
                        for (int newX = x + abortionModifier; abortionContinues; newX = newX + abortionModifier) {
                            tilePools.getRootPool().free(tiles[y][newX].getRoot());
                            if (newX == endingX) {
                                abortionContinues = false;
                            }
                        }


                    }
                    continues = false;
                    //in case the root is not closing yet, we will just add ordinary continous root
                } else {
                    tiles[y][x].setRoot(root);
                }






            } else {
                //AINIIN TÄMÄ EHKÄ KORJAANTUU SILLÄ KUN LAITTAA ETTEI VOI OLLA PELKKIÄ STONE
                //JUTTUJA
                System.out.println("probably bug gonna happen now");

                continues=false;
            }






            }



        return tiles;
    }
    //this method should be called before special tiles have been put to their list or hazards have been added
    public void addEnding(GameTile[][] tiles, TilePools tilePools, EntranceTile entranceTile) {
        int possiblePlace = 0;
        for (int x=1; x<tiles[0].length-1; x++) {
            if (!(tiles[tiles.length-2][x] instanceof StoneTile)) {
                possiblePlace++;
            }

        }


        int randomResult = -1;

        if (possiblePlace > 0) {
            randomResult=         MathUtils.random(1,possiblePlace);
        }



        //just a precaution to put it in middle in case there will be no possible place for entrance and randomResult is still -1
        //it shouldn't be possible for them all to be stone tiles at this point but it's a precaution if something
        //changes it

        int placeToBe=0;

        boolean continues=true;
        int entrancePlace;

        if (randomResult != -1) {

            for (int x=1; continues; x++) {
                GameTile currentTile = tiles[tiles.length-2][x];
                if (!(currentTile instanceof StoneTile)) {
                    placeToBe++;
                    if (randomResult == placeToBe) {
                        if (currentTile instanceof DirtTile) {
                            tilePools.getDirtPool().free((DirtTile)(currentTile));
                        } else if (currentTile instanceof DescendingDirtTile) {
                            tilePools.getDescendingPool().free((DescendingDirtTile)(currentTile));
                        } else if (currentTile instanceof BlankTile) {
                            tilePools.getBlankPool().free((BlankTile)(currentTile));
                        } else throw new IllegalArgumentException("Entrance tried to replace a tile that was not dirtTile, descendingTile or BlankTile");

                        tiles[tiles.length-2][x]=entranceTile;
                        entranceTile.setInPlace(tiles.length-2, x);
                        if (tiles[tiles.length-2][x] instanceof EntranceTile) {
                            continues=false;
                        }

                    }




                }

        }


        }





    }




    public void forceLevelToBePassable(Stage currentStage, MainGame mainGame) {

        GameTile[][] tiles = currentStage.tiles;
        //System.out.println(mainGame.entranceTile.getRawTileX());
        //passages = mainGame.passages;

        //passages[][] = new int[tiles.length][tiles[0].length]

        //we will define a "keyTile" in each row, which is the base of our checks for that row
        passages = new int[tiles.length][tiles[0].length];

        //    private static final int STARTING_TILE = 1;
        //    private static final int HORIZONTAL_HAZARD_NOT_ALLOWED = 2;
        //    private static final int KEYTILE = 3;

        //this will force first passage to start from entranceTile, that is always located on bottom of the level
        checkRow(tiles.length-2, mainGame.entranceTile.getRawTileX(), passages, currentStage, mainGame);
        //then it's possible to go all the way to top repeating this method
        for (int y=tiles.length-3; y>3; y--) {
            boolean foundStart=false;
            for (int x=1; !foundStart; x++) {
                //added hazardfreetile there as well to fight arrayIndexOutOfBound after creating hazardfreetile later
                if (passages[y][x] == STARTING_TILE || passages[y][x] == HAZARDFREETILE) {
                    checkRow(y, x, passages, currentStage, mainGame);
                    foundStart=true;
                }
            }
        }





    currentStage.passages=passages;


    }

    public void checkRow(int y, int startingX, int[][] passages, Stage currentStage, MainGame mainGame) {





        GameTile[][] tiles = currentStage.tiles;
        passages[y][startingX]=STARTING_TILE;

        //this is the case where the tile in top of STARTING_TILE is unpassable
        if (tiles[y-1][startingX].isConcrete() && !(tiles[y-1][startingX].isDiggable()) ) {

            //we'll check tiles in each direction, starting towards center so there won't so easily become
            // these long hallways that are apart from the other things in the map,
            // We have to make sure they don't have unproceedable pits below them.

            boolean turnMade=false;
            int modifier;



            if (startingX>3) {
                modifier=-1;



            } else {
                modifier=1;


            }



            boolean found = false;

            for (int x = startingX; !found; x = x +modifier) {

                //if we have reached the end in right edge, it's time to check the left passage
                if (x==TILES_IN_ROWS_WITHOUT_EDGES+1 && startingX > 1) {
                    if (turnMade==false) {
                        x=startingX;
                        modifier=-1;
                        turnMade=true;
                    //if we had already made the turn before, we must force the passage
                    } else {
                        forcePassage(y, startingX, passages, currentStage, mainGame);
                        found=true;
                    }

                //if we have reached the end of left direction , we have to check the right passage

                } else if (x==0 && startingX < TILES_IN_ROWS_WITHOUT_EDGES) {

                    if (turnMade==false) {
                        x=startingX;
                        modifier=1;
                        turnMade=true;
                    //if we had already made the turn before, we must force the passage
                    } else {
                        forcePassage(y, startingX, passages, currentStage, mainGame);
                        found=true;
                    }





                }
                //if the tile in horizontal line is unpassable, there is no need to check anymore, it's useless route
                else if (
                        (tiles[y][x].isConcrete() && ( !(tiles[y][x].isDiggable()) ) )
                        ||
                        //if there is no solid ground underneath, it is considered unpassable route as well. (descending dirt tile is still fine, since it's
                        //player's own fault if he stays there too long. There's enough time to even destroy a hazard and proceed
                        !tiles[y+1][x].isConcrete()
                )


                {

                    if(turnMade == false) {
                        x=startingX;
                        if (modifier ==1) {
                            modifier=-1;
                        } else {
                            modifier=1;
                        }
                        turnMade=true;
                    } else {
                        forcePassage(y, startingX, passages, currentStage, mainGame);
                        found=true;
                    }

                    //continues = false;






                //if we have passed this far, and the tile on top of the tile in check is passable, we have found a passage without forcing it
                } else if ( !tiles[y-1][x].isConcrete() || tiles[y-1][x].isDiggable() ) {
                    passages[y][x]=KEYTILE;
                    passages[y-1][x]=STARTING_TILE;

                    //there cant be horizontal shooting hazard in this row, since it might be impossible to pass with that in game in addition

                    passages[y][0]=HORIZONTAL_HAZARD_NOT_ALLOWED;
                    found=true;

                }
            }


        //this is the case when tile is top of starting X is actually passable, so there's no need to check anything else
        } else {
            passages[y - 1][startingX] = STARTING_TILE;
            passages[y][startingX] = KEYTILE;
        }

        //we will get rid of possible spike hazard on KEYTILE, since in case that it is the only passage, it would make the level unpassable
        Iterator<TileBasedObject> it = currentStage.hazardList.iterator();
        while (it.hasNext()) {
            TileBasedObject hazard = it.next();
            if ((passages[hazard.getTilePosY()][hazard.getTilePosX()] == KEYTILE) && (hazard instanceof Spike)) {
                currentStage.hazardPools.spikePool.free((Spike) hazard);
                it.remove();
            }

            //more added for the forcepassaged to right and left
            if ((passages[hazard.getTilePosY()][hazard.getTilePosX()] == HAZARDFREETILE)) {
                if (hazard instanceof Spike) {
                    currentStage.hazardPools.spikePool.free((Spike) hazard);
                } else if (hazard instanceof Goblin) {
                    currentStage.hazardPools.goblinPool.free((Goblin) hazard);
                } else if (hazard instanceof FallingTrap) {
                    currentStage.hazardPools.fallingTrapPool.free((FallingTrap) hazard);
                }
                it.remove();
            }

        }

    }

    public void forcePassage(int y, int startingX, int[][] passages, Stage currentStage, MainGame mainGame) {

        GameTile[][] tiles = currentStage.tiles;

        //we will actually make a one more check to prevent very long boring 1 tile wide tunnels on sides
        boolean threeStonesInARow = true;

        for (int yy = y-2; yy >= y-4; yy--) {
            if (!(tiles[yy][startingX] instanceof StoneTile)) {
                threeStonesInARow = false;
            }
        }

        if (!threeStonesInARow) {

            if (tiles[y-1][startingX] instanceof StoneTile) {
                mainGame.getTilePools().getStonePool().free( (StoneTile) tiles[y-1][startingX]);

                DirtTile dirtTile = mainGame.getTilePools().getDirtPool().obtain();

                tiles[y-1][startingX]=dirtTile;
                dirtTile.setInPlace(y-1, startingX);

                //tiles[y-1][startingX]=mainGame.getTilePools().getDirtPool().obtain();
                //tiles[y-1][startingX].putInTilePos(y-1, startingX);
            }

            passages[y - 1][startingX] = STARTING_TILE;
            passages[y][startingX] = KEYTILE;

        } else {
            //plan B to prevent those long hallways
            if (startingX == 1) {
                forcePassageTo(PASSAGERIGHT, y, startingX, passages, currentStage, mainGame);
            } else if (startingX == TILES_IN_ROWS_WITHOUT_EDGES) {
                forcePassageTo(PASSAGELEFT, y, startingX, passages, currentStage, mainGame);
            } else {
                //checking which route would have less stoneTiles, and starting to go towards that
                int stonesRight=0;
                int stonesLeft=0;
                for (int yy=y-1; (yy >= y-6) && (yy >= 2); yy--) {
                    if (tiles[yy][startingX+1] instanceof StoneTile) {
                        stonesRight++;
                    }
                    if (tiles[yy][startingX-1] instanceof StoneTile) {
                        stonesLeft++;
                    }
                }
                if (stonesRight > stonesLeft) {
                    forcePassageTo(PASSAGERIGHT, y, startingX, passages, currentStage, mainGame);
                } else if (stonesLeft > stonesRight) {
                    forcePassageTo(PASSAGELEFT, y, startingX, passages, currentStage, mainGame);
                //if they're still equal, going towards middle
                } else if (startingX >= 5) {
                    forcePassageTo(PASSAGELEFT, y, startingX, passages, currentStage, mainGame);
                } else if (startingX <= 4) {
                    forcePassageTo(PASSAGERIGHT, y, startingX, passages, currentStage, mainGame);
                }

            }
        }
    }

    public void forcePassageTo(int direction, int y, int startingX, int[][] passages, Stage currentStage, MainGame mainGame) {

        GameTile[][] tiles = currentStage.tiles;

        if (tiles[y-1][startingX] instanceof StoneTile) {
            mainGame.getTilePools().getStonePool().free( (StoneTile) tiles[y-1][startingX]);

            DirtTile dirtTile = mainGame.getTilePools().getDirtPool().obtain();

            tiles[y-1][startingX]=dirtTile;
            dirtTile.setInPlace(y-1, startingX);

        }

        if (tiles[y-1][startingX+direction] instanceof StoneTile) {

            mainGame.getTilePools().getStonePool().free( (StoneTile) tiles[y-1][startingX+direction]);

            DirtTile dirtTile = mainGame.getTilePools().getDirtPool().obtain();

            tiles[y-1][startingX+direction]=dirtTile;
            dirtTile.setInPlace(y-1, startingX+direction);

            passages[y-1][startingX+direction]=STARTING_TILE;

        /*POSSIBLE BUG PLACE*/
            // can be leaved as it is if it doesnt cause bugs
        } else {
            passages[y-1][startingX+direction]=STARTING_TILE;
        }
        if (tiles[y][startingX+direction] instanceof BlankTile) {

            mainGame.getTilePools().getBlankPool().free( (BlankTile) tiles[y][startingX+direction]);
            DirtTile dirtTile = mainGame.getTilePools().getDirtPool().obtain();

            tiles[y][startingX+direction]=dirtTile;
            dirtTile.setInPlace(y, startingX+direction);

            //hazards could be put to pool from this position
        }

        //doing this so there can be no spike in there
        passages[y][startingX]=KEYTILE;


        passages[y-1][startingX+direction]=HAZARDFREETILE;
        passages[y][startingX+direction]=HAZARDFREETILE;



    }








    /*
    public void randomizeTiles(int startingY, int startingX, int yAmount, int xAmount, GameTile[][] tiles) {


        for (int y = startingY; y < yAmount; y++) {
            for (int x = startingX; x < startingX+xAmount; x++) {
                tiles[y][x] = new DirtTile(y, x);
            }
        }


        for (int y = startingY; y < yAmount; y++) {
            for (int x = startingX; x < xAmount; x++) {
                int result = MathUtils.random(1,10);
                if (result == 10) {
                    tiles[y][x] = new PermanentTile(y, x);
                } else if (result == 8 || result ==9) {
                    tiles[y][x] = new BlankTile(y, x);
                }
            }
        }
    }
    */
}
